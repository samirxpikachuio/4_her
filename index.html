<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>For My Adrita ‚ù§Ô∏è</title>
  <!-- Three.js library -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <!-- Anime.js library for animations -->
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-weight: 100;
      touch-action: none; /* Prevents default touch actions like pan and zoom */
      overflow: hidden; /* Hide scrollbars if any */
      cursor: default;
    }
    #toggle-music {
      position: fixed;
      top: 16px;
      right: 16px;
      background: none;
      border: 2px solid #fff;
      border-radius: 50%;
      cursor: pointer;
      color: #fff;
      padding: 6px;
      transition: transform 0.2s ease;
      z-index: 999999;
    }
    #toggle-music.playing #icon-note,
    #toggle-music.playing #icon-note-slash {
      animation: spin 3s linear infinite;
    }
    #toggle-music svg {
      display: block;
    }
    @keyframes spin {
      from { transform: rotate(0deg);}
      to { transform: rotate(360deg);}
    }

    /* Welcome Overlay Styles */
    #adrita-welcome-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #ff69b4, #ffb6c1); /* Cute pink gradient */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000000; /* Ensure it's on top */
      color: white;
      font-family: 'Georgia', serif; /* A more romantic font */
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
      opacity: 0; /* Start hidden for Anime.js animation */
      pointer-events: none; /* Allow clicks through until animated in */
    }

    #adrita-welcome-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    #adrita-welcome-overlay h1 {
      font-size: 3.5em;
      margin-bottom: 20px;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
      opacity: 0; /* Start hidden for Anime.js animation */
      transform: translateY(-50px);
    }

    #adrita-welcome-overlay p {
      font-size: 1.5em;
      max-width: 80%;
      line-height: 1.6;
      margin-bottom: 30px;
      opacity: 0; /* Start hidden for Anime.js animation */
      transform: translateY(50px);
    }

    #adrita-welcome-overlay button {
      background-color: #fff; /* White button */
      color: #ff69b4; /* Pink text */
      border: none;
      padding: 15px 40px;
      border-radius: 30px; /* More rounded */
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
      letter-spacing: 1px;
      opacity: 0; /* Start hidden for Anime.js animation */
      transform: scale(0.5);
    }

    #adrita-welcome-overlay button:hover {
      background-color: #f0f0f0;
      transform: scale(1.05) translateY(-5px);
      box-shadow: 0 12px 25px rgba(0,0,0,0.3);
    }

    /* Optional: Small heart icon on the button */
    #adrita-welcome-overlay button::before {
      content: 'üíñ'; /* Cute heart emoji */
      margin-right: 10px;
    }

    /* Three.js Canvas initially hidden */
    #threejs-canvas {
      position: absolute; /* Allows it to take up full screen while being behind overlay */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none; /* Hidden until welcome is dismissed */
    }
  </style>
</head>
<body>
  <div id="threejs-canvas"></div>

  <!-- Audio element -->
  <audio id="bg-audio" preload="auto" loop></audio>

  <!-- Toggle music button -->
  <button id="toggle-music" aria-label="Toggle music">
    <svg id="icon-note" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
      <path d="M12 3v10.55A4 4 0 1 0 14 17V7h4V3h-6z" fill="currentColor"/>
    </svg>
    <svg id="icon-note-slash" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" style="display: none;">
      <path d="M10 3v10.55A4 4 0 1 0 12 15.55V5h4V3h-6z" fill="currentColor"/>
      <line x1="3" y1="3" x2="21" y2="21" stroke="currentColor" stroke-width="2"/>
    </svg>
  </button>

  <!-- Welcome Overlay HTML -->
  <div id="adrita-welcome-overlay">
    <h1 class="welcome-title">Hey, my dearest Adrita!</h1>
    <p class="welcome-subtitle">A little piece of my heart, just for you.<br>Tap to step into our special world filled with love and magic.</p>
    <button id="enterButton" class="welcome-button">Enter My World, My Love</button>
  </div>

  <script>
    const customTexts = [
      "I love you Adrita",
      "My CupCake",
      "The queen of my heart",
      "You're my everything",
      "My sweet Angel",
      "Forever yours"
    ];

    const audioSource = "https://files.catbox.moe/0zslug.m4a";
    document.getElementById('bg-audio').src = audioSource;

    const toggleBtn = document.getElementById("toggle-music");
    const audio = document.getElementById("bg-audio");
    const iconNote = document.getElementById("icon-note");
    const iconNoteSlash = document.getElementById("icon-note-slash");
    const welcomeOverlay = document.getElementById("adrita-welcome-overlay");
    const enterButton = document.getElementById("enterButton");
    const threeJsCanvas = document.getElementById("threejs-canvas");

    let isPlaying = false; 
    let threeJsInitialized = false;

    function updateIcon() {
      if (isPlaying) {
        iconNote.style.display = "block";
        iconNoteSlash.style.display = "none";
        toggleBtn.classList.add("playing");
      } else {
        iconNote.style.display = "none";
        iconNoteSlash.style.display = "block";
        toggleBtn.classList.remove("playing");
      }
    }

    function startAudio() {
      const playPromise = audio.play();
      if (playPromise !== undefined) {
        playPromise.then(() => {
          isPlaying = true;
          updateIcon();
        }).catch((err) => {
          isPlaying = false;
          updateIcon();
          console.error("Autoplay prevented:", err);
        });
      } else {
        isPlaying = true;
        audio.play();
        updateIcon();
      }
    }

    // Event listener for the music toggle button
    toggleBtn.addEventListener("click", () => {
      if (isPlaying) {
        audio.pause();
        isPlaying = false;
      } else {
        startAudio();
      }
      updateIcon();
    });

    // --- Anime.js Welcome Page Animations ---
    function animateWelcomePageIn() {
      welcomeOverlay.classList.add('active'); // Make overlay visible for animations

      anime.timeline({
        easing: 'easeOutExpo',
        duration: 1000
      })
      .add({
        targets: '#adrita-welcome-overlay h1',
        opacity: [0, 1],
        translateY: [-50, 0],
        delay: 200
      })
      .add({
        targets: '#adrita-welcome-overlay p',
        opacity: [0, 1],
        translateY: [50, 0],
        delay: 200
      })
      .add({
        targets: '#enterButton',
        opacity: [0, 1],
        scale: [0.5, 1],
        delay: 300,
        begin: function(anim) {
          // Add pulse animation to button after it appears
          anime({
            targets: '#enterButton',
            scale: [1, 1.05, 1],
            easing: 'easeInOutQuad',
            duration: 1500,
            loop: true,
            direction: 'alternate'
          });
        }
      });
    }

    function animateWelcomePageOut() {
      anime.timeline({
        easing: 'easeInExpo',
        duration: 800,
        complete: function(anim) {
          welcomeOverlay.style.display = 'none'; // Hide overlay after animation
          threeJsCanvas.style.display = 'block'; // Show Three.js canvas
          if (!threeJsInitialized) {
            initThreeJs(); // Initialize Three.js only once
            createStars();
            createFallingTexts();
            loadHeartImage().then(loadedHeartImage => {
              const heartTexture = createHeartTexture(loadedHeartImage);
              createFallingHearts(heartTexture);
              animateThreeJs(); // Start the Three.js render loop
            });
            threeJsInitialized = true;
          }
          startAudio(); // Start audio after user interaction
        }
      })
      .add({
        targets: '#adrita-welcome-overlay h1, #adrita-welcome-overlay p',
        opacity: 0,
        translateY: function(el, i) {
          return i === 0 ? -50 : 50; // Slide out based on element type
        }
      })
      .add({
        targets: '#enterButton',
        opacity: 0,
        scale: 0.5,
        delay: 0
      });
    }

    // Event listener for the "Enter My World, My Love" button
    enterButton.addEventListener("click", animateWelcomePageOut);

    // Initial setup on DOM load
    document.addEventListener("DOMContentLoaded", () => {
      animateWelcomePageIn(); // Animate welcome page in
      updateIcon(); // Initial icon state (paused)
    });

    // --- Three.js Animation Code ---
    let scene, camera, renderer; // Declare globally
    let starMeshes = [];
    let textMeshes = [];
    let heartMeshes = [];
    let shootingStars = [];

    let isDragging = false;
    let lastMouseX = 0;
    let isTouching = false;
    let lastTouchX = 0;
    let targetRotationY = 0.5;

    function initThreeJs() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ 'alpha': true });
      renderer.setSize(width, height);
      threeJsCanvas.appendChild(renderer.domElement); // Append to the hidden canvas

      camera.position.z = 20;
      camera.rotation.y = 0.5;
      
      setupCameraControls(); // Setup controls once
      window.addEventListener("resize", onWindowResize);
    }

    function onWindowResize() {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
    }

    function setupCameraControls() {
      renderer.domElement.addEventListener("mousedown", event => {
        isDragging = true;
        lastMouseX = event.clientX;
      });

      window.addEventListener("mouseup", () => {
        isDragging = false;
      });

      window.addEventListener("mousemove", event => {
        if (isDragging) {
          const deltaX = event.clientX - lastMouseX;
          lastMouseX = event.clientX;
          targetRotationY += deltaX * 0.0015;
        }
      });

      renderer.domElement.addEventListener("touchstart", event => {
        if (event.touches.length === 1) {
          isTouching = true;
          lastTouchX = event.touches[0].clientX;
        }
      });

      window.addEventListener("touchend", () => {
        isTouching = false;
      });

      window.addEventListener("touchmove", event => {
        if (isTouching && event.touches.length === 1) {
          const currentTouchX = event.touches[0].clientX;
          const deltaX = currentTouchX - lastTouchX;
          lastTouchX = currentTouchX;
          targetRotationY += deltaX * 0.0015;
        }
      });

      renderer.domElement.addEventListener("wheel", event => {
        event.preventDefault();
        camera.position.z += event.deltaY * 0.006;
        camera.position.z = Math.max(3, Math.min(camera.position.z, 50));
      });
    }

    function loadHeartImage(imageUrl = "https://files.catbox.moe/8tqj6k.png") {
      return new Promise((resolve, reject) => {
        const image = new Image();
        image.crossOrigin = 'anonymous'; 
        image.onload = () => resolve(image);
        image.onerror = (e) => {
          console.error("Error loading image:", e);
          const fallbackImageUrl = "https://placehold.co/256x256/ff0000/ffffff?text=Error";
          const fallbackImage = new Image();
          fallbackImage.onload = () => resolve(fallbackImage);
          fallbackImage.onerror = () => reject(new Error("Fallback image failed too."));
          fallbackImage.src = fallbackImageUrl;
          fallbackImage.crossOrigin = 'anonymous'; 
        };
        image.src = imageUrl;
      });
    }

    function createTextTexture(textContent, fontSize = 96) {
      const tempCanvas = document.createElement("canvas");
      const tempContext = tempCanvas.getContext('2d');
      tempContext.font = `bold ${fontSize}px 'Arial'`;

      let textWidth = tempContext.measureText(textContent).width;

      if (textWidth + 200 > 1200) {
        fontSize = Math.floor(fontSize * 1000 / textWidth);
        tempContext.font = `bold ${fontSize}px 'Arial'`;
        textWidth = tempContext.measureText(textContent).width;
      }

      const finalCanvasWidth = Math.ceil(textWidth + 200);
      const textCanvas = document.createElement("canvas");
      textCanvas.width = finalCanvasWidth;
      textCanvas.height = 384;

      const textContext = textCanvas.getContext('2d');
      textContext.font = `bold ${fontSize}px 'Arial'`;
      textContext.textAlign = 'center';
      textContext.textBaseline = 'middle';
      textContext.shadowColor = '#ff69b4';
      textContext.shadowBlur = 50;
      textContext.fillStyle = "rgba(255, 255, 255, 0.8)";
      textContext.fillText(textContent, textCanvas.width / 2, textCanvas.height / 2);
      textContext.strokeStyle = '#fff';
      textContext.lineCap = "round";
      textContext.lineWidth = 2;
      textContext.strokeText(textContent, textCanvas.width / 2, textCanvas.height / 2);

      return {
        'texture': new THREE.CanvasTexture(textCanvas),
        'aspect': textCanvas.width / textCanvas.height
      };
    }

    function createHeartTexture(heartImage) {
      const heartCanvas = document.createElement("canvas");
      heartCanvas.width = 256;
      heartCanvas.height = 256;
      const heartContext = heartCanvas.getContext('2d');

      heartContext.clearRect(0, 0, heartCanvas.width, heartCanvas.height);
      heartContext.shadowColor = "#ff69b4";
      heartContext.shadowBlur = 30;

      const drawWidth = heartCanvas.width / 2;
      const drawHeight = heartCanvas.height / 2;
      const offsetX = (heartCanvas.width - drawWidth) / 2;
      const offsetY = (heartCanvas.height - drawHeight) / 2;

      heartContext.drawImage(heartImage, offsetX, offsetY, drawWidth, drawHeight);
      return new THREE.CanvasTexture(heartCanvas);
    }

    function createStars() {
      const starGeometry = new THREE.SphereGeometry(0.07, 6, 6);
      const starMaterial = new THREE.MeshBasicMaterial({
        'color': 0xffffff
      });

      for (let i = 0; i < 800; i++) {
        const starMesh = new THREE.Mesh(starGeometry, starMaterial);
        starMesh.position.x = (Math.random() - 0.5) * 120;
        starMesh.position.y = Math.random() * 80 - 20;
        starMesh.position.z = (Math.random() - 0.5) * 120 - 20;
        scene.add(starMesh);
        starMeshes.push(starMesh);
      }
    }

    function createFallingTexts() {
      textMeshes.forEach(mesh => scene.remove(mesh));
      textMeshes = [];

      for (let i = 0; i < 200; i++) {
        const randomText = customTexts[Math.floor(Math.random() * customTexts.length)];
        const {
          texture: textTexture,
          aspect: textAspect
        } = createTextTexture(randomText);

        textTexture.needsUpdate = true;

        const planeWidth = 3 * textAspect;
        const textPlaneGeometry = new THREE.PlaneGeometry(planeWidth, 3);
        const textMaterial = new THREE.MeshBasicMaterial({
          'map': textTexture,
          'transparent': true,
          'depthWrite': false,
          'depthTest': true,
          'color': 0xffffff
        });
        const textMesh = new THREE.Mesh(textPlaneGeometry, textMaterial);

        textMesh.position.x = (Math.random() - 0.5) * 100;
        textMesh.position.y = Math.random() * 32 - 12;
        textMesh.position.z = (Math.random() - 0.5) * 40;
        textMesh.userData.phase = Math.random() * Math.PI * 2;
        scene.add(textMesh);
        textMeshes.push(textMesh);
      }
    }

    function createFallingHearts(heartTexture) {
      heartMeshes.forEach(mesh => scene.remove(mesh));
      heartMeshes = [];

      for (let i = 0; i < 15; i++) {
        const heartPlaneGeometry = new THREE.PlaneGeometry(1, 1);
        const heartMaterial = new THREE.MeshBasicMaterial({
          'map': heartTexture,
          'transparent': true,
          'depthWrite': false,
          'depthTest': true
        });
        const heartMesh = new THREE.Mesh(heartPlaneGeometry, heartMaterial);

        heartMesh.position.x = (Math.random() - 0.5) * 30;
        heartMesh.position.y = Math.random() * 32 - 12;
        heartMesh.position.z = (Math.random() - 0.5) * 20;
        const scaleFactor = 1 + Math.random() * 1.5;
        heartMesh.scale.set(scaleFactor, scaleFactor, 1);
        scene.add(heartMesh);
        heartMeshes.push(heartMesh);
      }
    }

    function spawnShootingStar() {
      const starGeometry = new THREE.SphereGeometry(0.15, 8, 8);
      const starMaterial = new THREE.MeshBasicMaterial({
        'color': 0xffffff,
        'transparent': true
      });
      const shootingStarMesh = new THREE.Mesh(starGeometry, starMaterial);

      shootingStarMesh.position.x = (Math.random() - 0.5) * 100;
      shootingStarMesh.position.y = Math.random() * 80 - 20; 
      shootingStarMesh.position.z = -40 - Math.random() * 40; 
      shootingStarMesh.userData = {
        'vx': 0.4 + Math.random() * 0.3,
        'vy': -0.2 - Math.random() * 0.2,
        'vz': 0.7 + Math.random() * 0.5,
        'tail': []
      };
      scene.add(shootingStarMesh);
      shootingStars.push(shootingStarMesh);
    }

    // Main animation loop for Three.js
    function animateThreeJs() {
      requestAnimationFrame(animateThreeJs);

      // Animate main scene elements
      camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.08;

      const currentTime = Date.now();

      textMeshes.forEach(textMesh => {
        textMesh.position.y -= 0.025 + Math.random() * 0.005;

        if (textMesh.position.y < -12) {
          textMesh.position.y = Math.random() * 20 + 10;
          textMesh.position.x = (Math.random() - 0.5) * 30;
          textMesh.position.z = (Math.random() - 0.5) * 40;
        }

        if (textMesh.position.x > 16) {
          textMesh.position.x = -16;
        }
        if (textMesh.position.x < -16) {
          textMesh.position.x = 16;
        }

        const colorInterpolation = (Math.sin(currentTime * 0.0005 + textMesh.userData.phase) + 1) / 2;
        const startColor = [255, 255, 255];
        const endColor = [255, 105, 180];
        const animatedColor = [
          Math.round(startColor[0] + (endColor[0] - startColor[0]) * colorInterpolation),
          Math.round(startColor[1] + (endColor[1] - startColor[1]) * colorInterpolation),
          Math.round(startColor[2] + (endColor[2] - startColor[2]) * colorInterpolation)
        ];
        const hexColor = (animatedColor[0] << 16) | (animatedColor[1] << 8) | animatedColor[2];
        textMesh.material.color.setHex(hexColor);
      });

      heartMeshes.forEach(heartMesh => {
        heartMesh.position.y -= 0.04 + Math.random() * 0.02;
        heartMesh.position.x += (Math.random() - 0.5) * 0.05;

        if (heartMesh.position.y < -12) {
          heartMesh.position.y = Math.random() * 20 + 10;
          heartMesh.position.x = (Math.random() - 0.5) * 30;
          heartMesh.position.z = (Math.random() - 0.5) * 20;
        }

        if (heartMesh.position.x > 16) {
          heartMesh.position.x = -16;
        }
        if (heartMesh.position.x < -16) {
          heartMesh.position.x = 16;
        }
      });

      shootingStars.forEach((starMesh, index) => {
        if (starMesh.userData.tail.length > 20) {
          starMesh.userData.tail.shift();
        }
        starMesh.userData.tail.push({
          'x': starMesh.position.x,
          'y': starMesh.position.y,
          'z': starMesh.position.z
        });

        starMesh.position.x += starMesh.userData.vx;
        starMesh.position.y += starMesh.userData.vy;
        starMesh.position.z += starMesh.userData.vz;

        for (let i = 0; i < starMesh.userData.tail.length - 1; i++) {
          const startPoint = starMesh.userData.tail[i];
          const endPoint = starMesh.userData.tail[i + 1];
          const lineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(startPoint.x, startPoint.y, startPoint.z),
            new THREE.Vector3(endPoint.x, endPoint.y, endPoint.z)
          ]);
          const lineMaterial = new THREE.LineBasicMaterial({
            'color': 0xffffff,
            'transparent': true,
            'opacity': 0.15 + 0.25 * (i / starMesh.userData.tail.length)
          });
          const tailLine = new THREE.Line(lineGeometry, lineMaterial);
          scene.add(tailLine);
          setTimeout(() => scene.remove(tailLine), 40);
        }

        starMesh.material.opacity = 0.8;

        if (starMesh.position.z > 0 || starMesh.position.y < -40) {
          scene.remove(starMesh);
          shootingStars.splice(index, 1);
        }
      });

      if (Math.random() < 0.012) {
        spawnShootingStar();
      }
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
